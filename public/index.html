<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer Game</title>
  <style>
    #roomId, #joinButton {
      display: none;
    }
  </style>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>
<body>
  <input type="text" id="roomId" placeholder="Enter room ID">
  <button id="joinButton">Join Room</button>

  <script>
    const socket = io();
    socket.on('connect', () => {
      console.log('Connected to server');
    });

    // Menu Scene: Room joining interface
    class MenuScene extends Phaser.Scene {
      constructor() {
        super({ key: 'MenuScene' });
      }

      create() {
        this.add.text(400, 200, 'Enter Room ID to Join', { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
        const roomIdInput = document.getElementById('roomId');
        const joinButton = document.getElementById('joinButton');
        roomIdInput.style.display = 'block';
        joinButton.style.display = 'block';

        socket.on('roomFull', (data) => {
          console.log(data.message);
          this.add.text(400, 300, 'Room is Full', { fontSize: '24px', fill: '#ff0000' }).setOrigin(0.5);
        });

        socket.on('joinedRoom', (data) => {
          console.log('Joined room:', data.roomId);
          this.scene.start('WaitingScene');
        });

        joinButton.onclick = () => {
          const roomId = roomIdInput.value;
          if (roomId) socket.emit('joinRoom', roomId);
        };
      }
    }

    // Waiting Scene: Wait for second player
    class WaitingScene extends Phaser.Scene {
      constructor() {
        super({ key: 'WaitingScene' });
      }

      create() {
        document.getElementById('roomId').style.display = 'none';
        document.getElementById('joinButton').style.display = 'none';
        this.waitingText = this.add.text(400, 300, 'Waiting for another player...', { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
      }
    }

    // Game Scene: Main gameplay
    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
        this.submittedWords = new Set(); // Track submitted words
        this.multiplier = 1; // Initialize damage multiplier
      }

      create() {
        // Initialize HP
        this.playerHP = 100;
        this.opponentHP = 100;
        this.gameEnded = false;

        // Draw castles
        this.add.rectangle(150, 500, 100, 100, 0x00ff00); // Player's castle (moved right)
        this.add.rectangle(850, 500, 100, 100, 0xff0000); // Opponent's castle (moved right)

        // Castle labels
        this.add.text(150, 560, 'Your Castle', { fontSize: '18px', fill: '#fff' }).setOrigin(0.5);
        this.add.text(850, 560, 'Opponents Castle', { fontSize: '18px', fill: '#fff' }).setOrigin(0.5);

        // Player HP bar and text
        this.playerHPBar = this.add.graphics();
        this.playerHPBar.lineStyle(2, 0xffffff, 1);
        this.playerHPBar.strokeRect(100, 420, 100, 10);
        this.playerHPBar.fillStyle(0x00ff00, 1);
        this.playerHPBar.fillRect(100, 420, 100, 10);
        this.playerHPText = this.add.text(150, 410, '100', { fontSize: '16px', fill: '#fff' }).setOrigin(0.5);

        // Opponent HP bar and text
        this.opponentHPBar = this.add.graphics();
        this.opponentHPBar.lineStyle(2, 0xffffff, 1);
        this.opponentHPBar.strokeRect(800, 420, 100, 10);
        this.opponentHPBar.fillStyle(0xff0000, 1);
        this.opponentHPBar.fillRect(800, 420, 100, 10);
        this.opponentHPText = this.add.text(850, 410, '100', { fontSize: '16px', fill: '#fff' }).setOrigin(0.5);

        // Word and input UI
        this.wordText = this.add.text(500, 50, 'многоножка', { fontSize: '40px', fill: '#fff' }).setOrigin(0.5); // Even bigger font
        this.inputText = this.add.text(500, 150, '', { fontSize: '28px', fill: '#fff' }).setOrigin(0.5);
        this.damageText = this.add.text(500, 100, '', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
        
        // Multiplier display
        this.multiplierText = this.add.text(500, 200, 'Multiplier: x1.0', { fontSize: '20px', fill: '#fff' }).setOrigin(0.5);
        
        // Game results
        this.resultText = this.add.text(500, 300, '', { fontSize: '48px', fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5);
        this.resultText.setVisible(false);

        this.playerInput = ''; // Initialize player input
        this.givenWord = 'многоножка'; // Store the given word

        // Update HP bars based on server data
        socket.on('updateHP', (data) => {
          this.playerHP = data.yourHP;
          this.opponentHP = data.opponentHP;
          this.updatePlayerHPBar();
          this.updateOpponentHPBar();

          // Check for game end
          if (!this.gameEnded && (this.playerHP <=0 || this.opponentHP <=0)) {
            this.endGame();
          }
        });
        
        // Handle word validation result
        socket.on('wordResult', (result) => {
          if (result.valid) {
            this.damageText.setText(`Нанесено урона: ${result.damage}`);
            this.damageText.setColor('#00ff00');
            
            // Increase multiplier on successful word
            if (result.increaseMultiplier) {
              this.multiplier += 0.2;
              this.updateMultiplierDisplay();
            }
          } else {
            this.damageText.setText(`Недопустимое слово: ${result.reason}`);
            this.damageText.setColor('#ff0000');
            
            // Reset multiplier on failed word
            if (result.resetMultiplier) {
              this.multiplier = 1.0;
              this.updateMultiplierDisplay();
            }
          }
        });

        // Handle keyboard input
        this.input.keyboard.on('keydown', (event) => {
          if (event.key === 'Enter') {
            if (this.playerInput) {
              // Check if word is too short
              if (this.playerInput.length < 3) {
                this.damageText.setText('Слово должно быть не менее 3 букв');
                this.damageText.setColor('#ff0000');
                this.multiplier = 1.0;
                this.updateMultiplierDisplay();
              }
              // Check if word is the same as given word
              else if (this.playerInput.toLowerCase() === this.givenWord.toLowerCase()) {
                this.damageText.setText('Нельзя использовать исходное слово');
                this.damageText.setColor('#ff0000');
                this.multiplier = 1.0;
                this.updateMultiplierDisplay();
              } 
              // Check if word was already submitted by this player
              else if (this.submittedWords.has(this.playerInput.toLowerCase())) {
                this.damageText.setText('Это слово уже использовано');
                this.damageText.setColor('#ff0000');
                this.multiplier = 1.0;
                this.updateMultiplierDisplay();
              }
              else {
                socket.emit('submitWord', { 
                  word: this.playerInput,
                  multiplier: this.multiplier
                });
                this.submittedWords.add(this.playerInput.toLowerCase()); // Add to submitted words
              }
              this.playerInput = '';
              this.inputText.setText('');
            }
          } else if (event.key === 'Backspace') {
            this.playerInput = this.playerInput.slice(0, -1);
            this.inputText.setText(this.playerInput);
          } else if (event.key.length === 1) {
            this.playerInput += event.key;
            this.inputText.setText(this.playerInput);
          }
        });
      }

      updateMultiplierDisplay() {
        // Format multiplier to one decimal place
        const formattedMultiplier = this.multiplier.toFixed(1);
        this.multiplierText.setText(`Multiplier: x${formattedMultiplier}`);
        
        // Change color based on multiplier value
        if (this.multiplier > 2.0) {
          this.multiplierText.setColor('#ff9900'); // Orange for high multiplier
        } else if (this.multiplier > 1.0) {
          this.multiplierText.setColor('#00ff00'); // Green for increased multiplier
        } else {
          this.multiplierText.setColor('#ffffff'); // White for base multiplier
        }
      }

      updatePlayerHPBar() {
        const hpPercentage = this.playerHP / 100;
        this.playerHPBar.clear();
        this.playerHPBar.lineStyle(2, 0xffffff, 1);
        this.playerHPBar.strokeRect(100, 420, 100, 10);
        
        // Color gradient based on HP percentage
        let fillColor;
        if (hpPercentage > 0.5) {
          // Green to yellow gradient (100% to 50%)
          const greenComponent = Math.floor(255 * (hpPercentage - 0.5) * 2);
          fillColor = Phaser.Display.Color.GetColor(greenComponent, 255, 0);
        } else {
          // Yellow to red gradient (50% to 0%)
          const redComponent = 255;
          const greenComponent = Math.floor(255 * hpPercentage * 2);
          fillColor = Phaser.Display.Color.GetColor(redComponent, greenComponent, 0);
        }
        
        this.playerHPBar.fillStyle(fillColor, 1);
        this.playerHPBar.fillRect(100, 420, 100 * hpPercentage, 10);
        this.playerHPText.setText(this.playerHP);
      }

      updateOpponentHPBar() {
        const hpPercentage = this.opponentHP / 100;
        this.opponentHPBar.clear();
        this.opponentHPBar.lineStyle(2, 0xffffff, 1);
        this.opponentHPBar.strokeRect(800, 420, 100, 10);
        
        // Color gradient based on HP percentage
        let fillColor;
        if (hpPercentage > 0.5) {
          // Green to yellow gradient (100% to 50%)
          const greenComponent = Math.floor(255 * (hpPercentage - 0.5) * 2);
          fillColor = Phaser.Display.Color.GetColor(greenComponent, 255, 0);
        } else {
          // Yellow to red gradient (50% to 0%)
          const redComponent = 255;
          const greenComponent = Math.floor(255 * hpPercentage * 2);
          fillColor = Phaser.Display.Color.GetColor(redComponent, greenComponent, 0);
        }
        
        this.opponentHPBar.fillStyle(fillColor, 1);
        this.opponentHPBar.fillRect(800, 420, 100 * hpPercentage, 10);
        this.opponentHPText.setText(this.opponentHP);
      }

      endGame() {
        this.gameEnded = true;

        // Disable input
        this.input.keyboard.removeAllListeners();
        
        // Show winner message
        if (this.playerHP <= 0) {
          this.resultText.setText('You Lost!');
        } else {
          this.resultText.setText('You Won!');
        }
        this.resultText.setVisible(true);
        
        // Notify server about game end
        socket.emit('gameEnded', { winner: this.playerHP > 0 ? socket.id : null });
      }
    }

    // Phaser game configuration
    const config = {
      type: Phaser.AUTO,
      width: 1000, // Increased from 800 to 1000
      height: 600,
      scene: [MenuScene, WaitingScene, GameScene]
    };

    const game = new Phaser.Game(config);

    // Global listener for startGame
    socket.on('startGame', (data) => {
      console.log('Received startGame:', data.message);
      // Check if WaitingScene is active before stopping it
      if (game.scene.isActive('WaitingScene')) {
        console.log('Stopping WaitingScene');
        game.scene.stop('WaitingScene');
      }
      // Ensure GameScene starts cleanly
      console.log('Starting GameScene');
      game.scene.start('GameScene');
    });
  </script>
</body>
</html>